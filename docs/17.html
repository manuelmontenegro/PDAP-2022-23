<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Introducción a la programación reactiva con RxJS</title>

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nunito" />
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/pdap.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/nnfx-light.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
      
      <section data-background-image="img/RedBackground.jpg">
        <div style="background-color:white;height:1em"></div>
        <h1 style="color:white;font-size:240%">Introducción a la programación reactiva con RxJS</h1>
        <div style="background-color:white;height:1em"></div>

        <div style="display:flex;justify-content:space-around;align-items:center;text-align:right">
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span>Manuel Montenegro Montes</span><br>
          <span><a href="montenegro@fdi.ucm.es" style="color:#ff9999">montenegro@fdi.ucm.es</a></span><br>           </div>
          
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span><b>Programación Declarativa Aplicada</b></span><br>
          <span>Máster en Ingeniería Informática</span><br>
          <span>Facultad de Informática</span><br>
          <span>Universidad Complutense de Madrid</span><br>
          </div>            
        </div>

      </section>

        
      
      <section data-background-image="img/RedBackground.jpg" data-background-transition="fade">
          <ol class="contenidos">
            <li>¿Qué es la programación reactiva?</li>
            <li>ReactiveX y RxJS</li>
            <li>Ejemplos</li>
            <li>Resumen de operadores</li>
          </ol>
      </section>
      
    <section>
      <section>
        <h2>¿Qué es la programación reactiva?</h2>
      </section>
      
      <section>
        <h3>¿Qué es la programación reactiva?</h3>
        <ul>
          <li>Es un paradigma de programación relacionado con la <strong>evolución</strong> de las variables a lo largo del tiempo, y la <strong>propagación</strong> de los cambios que en ellas se producen.</li>
          <li>Consiste en representar flujos de datos (<strong><em>data streams</em></strong>) que describen el valor de una variable a lo largo del tiempo.         </li>
        </ul>
      </section>
      
      
      <section>
        <h3>Ejemplo: hojas de cálculo</h3>
        <ul>
          <li>Las hojas de cálculo son uno de los ejemplos mas representativos de la programación reactiva.</li>
          <li>En una hoja de cálculo, cada celda tiene un valor que puede depender de otras celdas.
          <p style="text-align:center"><img src="17/HojaCalculo.png"></p>
          </li>
          <li class="fragment">La celda <code>B2</code> <strong>se recalcula automáticamente</strong> cada vez que hay un cambio en alguna de las celdas de las que depende (<code>A1</code> o <code>A2</code>).</li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo: hojas de cálculo</h3>
        <ul>
          <li>En programación reactiva, los datos representan valores de las celdas a lo largo del tiempo.</li>          
        </ul>
        <p><img src="17/Cronograma.svg" width="90%"></p>
      </section>
      
      <section>
        <h3>Propagación del cambio</h3>
        <ul>
          <li>En programación orientada a objetos, el patrón de diseño más conocido para propagar cambios de estado es el patrón <em class="fragment">Observer</em>.</li>
          <li class="fragment">En este patrón, varios <em>observers</em> (o <em>listeners</em>) se registran en un <strong>observable</strong> para ser notificados de los cambios producidos en este último.</li>
          <li class="fragment">Cuando un observable modifica su estado, emite un <strong>evento  </strong> para que sus observadores puedan realizar las acciones oportunas.</li>
        </ul>
      </section>
      
      <section>
        <h3>Propagación del cambio</h3>
        <ul>
          <li>La manera habitual de representar eventos emitidos por un observable son los <strong>diagramas de canicas</strong> (<em>marble diagrams</em>).
          </li>
        </ul>
        <div style="display:flex;align-items:center">
        <p style="width:50%"><img src="17/canicas.svg" class="fragment"></p>
        <p style="width:50%;background-color:#FFFFCC;padding:10px 0px" class="fragment">Las canicas representan los valores emitidos por cada observable a lo largo del tiempo.</p>
        </div>
      </section>
      
      <section>
        <h3>Programación reactiva</h3>
        <ul>
          <li>Con este modelo basado en <strong>observables</strong>, la programación reactiva consiste en <strong>transformar</strong> y <strong>combinar</strong> observables para obtener otros observables como resultado.</li>
          <li class="fragment">
        Cuando definimos un observable, estamos indicando el comportamiento dinámico que tendrá un determinado valor a lo largo de la ejecución del programa.
        </li>
        </ul>
      </section>
    </section>
      
    <section>
      <section>
        <h2>ReactiveX y RXJS</h2>
      </section>
      <section>
        <h3>ReactiveX</h3>
        <div style="display:flex;align-items:center;justify-content:space-evenly">
        <p><img src="https://avatars.githubusercontent.com/u/6407041?s=200&v=4"></p>
        <p><a href="https://reactivex.io/">https://reactivex.io/</a></p>
        </div>
        <ul>
          <li><em>ReactiveX</em> es una librería basada en el uso de observables para componer programas asíncronos y basados en eventos.</li>
        </ul>
      </section>
      
      <section>
        <h3>ReactiveX</h3>
        <ul>
          <li>Disponible en los siguientes lenguajes:
          <ul>
            <li>JavaScript - <a href="https://rxjs.dev/">RxJS</a>
            <span class="arrow_box_left fragment" style="position:relative;left:3em">Este curso</a>            <li>Java/Kotlin - <a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>

            </li>
            <li>C# - <a href="https://github.com/dotnet/reactive">Rx.NET</a></li>
            <li>Python - <a href="https://github.com/ReactiveX/RxPY">RxPY</a></li>
            <li>C++ - <a href="https://github.com/ReactiveX/RxCpp">RxCpp</a></li>
            <li>Go - <a href="https://github.com/ReactiveX/RxGo">RxGo</a></li>
            <li>Lua, Ruby, Swift, Dart, Elixir, etc.</li>
            
            
          </ul>
          </li>
        </ul>
      </section>
    </section>
    
    <section>
      <section>
        <h2>Ejemplos</h2>
      </section>
    </section>
      
    <section>
      <section>
        <p class="info_box">Ejemplo 1:<br/>Capturar pulsaciones de ratón</p>
        <div class="fragment">
        <p style="font-style:italic">En este ejemplo estudiaremos los operadores básicos:</p>
        <p><code>fromEvent</code>, <code>map</code>, <code>filter</code>, <code>take</code>, <code>reduce</code>, <code>scan</code>, <code>zip</code>
        </div>
      </section>
      

    
      <section>
        <h3>Ejemplo</h3>
        <p>Comenzamos con la siguiente página HTML:</p>
        <div style="display:flex">
          <div style="width:50%"><p><code>index.html</code></p>
            <pre style="font-size:40%"><code class="language-html" data-trim data-noescape>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Captura de eventos&lt;/title&gt;
            &lt;link rel="stylesheet" href="index.css"/&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="areaClicks"&gt;&lt;/div&gt;
            &lt;script src="main.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;          
            </code></pre>
          </div>
          <div style="width:50%"><p><code>index.css</code></p>
            <pre style="font-size:40%"><code class="language-css" data-trim data-noescape>    
#areaClicks {
    width: 600px;
    height: 300px;
    background-color: lightblue;
}          
            </code></pre>
            <img src="17/Ventana1.png" width="80%">            
          </div>          
        </div>
      </section>

      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Obtenemos una referencia al elemento DOM correspondiente al área sombreada <code>&lt;div&gt;</code> de la página:
          <pre><code class="language-javascript" data-trim data-noescape>
            const area = document.getElementById('areaClicks');
          </code></pre>
          </li>
        </ul>
      </section>
      
      
      <section>
        <h3>Detección de pulsaciones</h3>
        <ul>
          <li>Construimos un observable a partir de las pulsaciones de ratón realizadas sobre el área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape data-line-numbers="1,4">
import { fromEvent } from 'rxjs';

const area = document.getElementById('areaClicks');
const click$ = fromEvent(area, 'click');            
          </code></pre>
          <p style="text-align:center" class="fragment"><img src="17/clicks1.svg"></p>
          </li>
          <li class="fragment">Por convenio, los nombres de las variables que contienen observables finalizan en <code>$</code>.</li>
          
        </ul>
      </section>
      
      <section>
        <h3>El método <code>fromEvent</code></h3>
        <ul>
          <li><code>fromEvent(e, type)</code><br/>
          Construye un observable a partir de los eventos de tipo <code>type</code> que se producen en el elemento <code>e</code> de la página.
          </li>
          <div class="fragment">
          <li>Cada elemento del observable creado es un objeto de la interfaz <code>Event</code> de JavaScript.</li>
          <li>En el caso de los eventos provenientes del ratón (<code>click</code>, por ejemplo) es un objeto de la clase <code>MouseEvent</code>.</li></div>
        </ul>
      </section>
      
      
      <section>
        <h3>Suscripción a un observable</h3>
        <p style="text-align:center;margin:0px"><img src="17/clicks1.svg"></p>
        <ul>
          <li>Mediante el método <code>subscribe()</code> de los observables podemos indicar las acciones a realizar cada vez que se produce un evento en <code>click$</code>:
          <pre class="fragment"><code class="language-javascript" data-trim data-noescape>
click$.subscribe((click) => console.log('Click! ', click));
          </code></pre>
          </li>
          <li class="fragment">La función pasada a <code>subscribe()</code> recibe el objeto <code>MouseEvent</code> correspondiente a cada pulsación.</li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores RxJS</h3>
        <ul>
          <li>Permiten transformar un observable en otro, o combinar varios observables.</li>
          <li>Son operaciones <strong>puras</strong>: generan un nuevo observable sin alterar el original.</li>
          <li class="fragment">Para aplicar una secuencia de operadores a un observable se utiliza el método <code>pipe()</code>:
          <pre><code class="language-javascript" data-trim data-noescape>
            const destino$ = origen$.pipe(
                operacion1(),
                operacion2(),
                ...
            )
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores RxJS</h3>
        <img src="17/operadores.svg" width="50%">
      </section>
      
      <section>
        <h3>El operador <code>map</code></h3>
        <ul>
          <li>Produce un observable aplicando una función dada a cada valor del observable original.         
          </li>          
        </ul>
        <p><img src="17/map.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Obtenemos un observable con las coordenadas cada pulsación del ratón:
          <pre><code class="language-javascript" data-trim data-noescape>
            import { fromEvent, map } from 'rxjs';
            ...
            const click$ = fromEvent(area, 'click').pipe(
                map(evt => ({x: evt.offsetX, y: evt.offsetY}))
            );
            
            click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <img src="17/clicks2.svg">
      </section>
      
      
      <section>
        <h3>El operador <code>filter</code></h3>
        <ul>
          <li>Produce un observable a partir de los eventos de otro, concretamente aquellos para los que la función booleana pasada como parámetro devuelve <code>true</code>.</li>
        </ul>
        <p><img src="17/filter.svg"></p>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que solo queremos informar de las pulsaciones de ratón que se producen en la mitad izquierda del área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter } from 'rxjs';
...
const click$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    <span class="hl">filter(({x, y}) => x < area.clientWidth / 2)</span>
);

click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>take</code></h3>
        <ul>
          <li>Aplicado a un número <code>n</code>, produce un observable con los <code>n</code> primeros valores del observable inicial.</li>
        </ul>
        <p><img src="17/take.svg"></p>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Modificamos el ejemplo anterior para capturar solamente las diez primeras pulsaciones del ratón.</li>
        </ul>
        <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter, take } from 'rxjs';
...
const click$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    filter(({x, y}) => x < area.clientWidth / 2),
    <span class="hl">take(10)</span>
);

click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
        </code></pre>
      </section>
        
      <section>
        <h3>El operador <code>reduce</code></h3>
        <ul>
          <li>Similar a la función <code>reduce</code> de JavaScript.</li>
          <li>Mantiene un acumulador que se actualiza a medida que el observable origen produce valores.</li>
          <li>Cuando el observable origen finaliza, se emite el valor final del acumulador.</li>
        </ul>
        <p><img src="17/reduce.svg"></p>
      </section>
      
      <section>
        <h3>El operador <code>scan</code></h3>
        <ul>
          <li>Similar a <code>reduce</code>, pero el observable resultante emite los valores intermedios del acumulador.</li>
        </ul>
        <img src="17/scan.svg">
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que queremos contar el número de pulsaciones de ratón sobre el área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter, take, scan } from 'rxjs';
...

const click$ = fromEvent(area, 'click');
const cont$ = click$.pipe(scan((ac, _) => ac + 1, 0));

cont$.subscribe(cont => console.log(`Contador: ${cont}`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>zip</code></h3>
        <ul>
          <li>Combina varios observables en uno solo.</li>
          <li>Cada valor del resultado es una agrupación formada a partir de los valores emitidos por cada observable.</li>
        </ul>
        <p><img src="17/zip.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Combinamos los dos observables anteriores:
          <ul>
            <li><code>coord$</code>: coordenadas de cada pulsación</li>
            <li><code>cont$</code>: número de pulsaciones</li>
          </ul>          
          </li>
        </ul>
        <p><img src="17/clicks3.svg" width="60%"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <pre><code class="language-javascript" data-trim data-noescape>

import { fromEvent, map, filter, take, scan, zip } from 'rxjs';

const area = document.getElementById('areaClicks');

const coord$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    filter(({x, y}) => x < area.clientWidth / 2)
);

const cont$ = coord$.pipe(scan((ac, _) => ac + 1, 0));

zip(coord$, cont$)
    .pipe(take(10))
    .subscribe(([{x, y}, cont]) => {
        console.log(`Pulsación en (${x}, ${y}) / contador = ${cont}`);
    });
        </code></pre>
      </section>      
    </section>
    
    
    
    <section>
      <section>
        <p class="info_box">Ejemplo 2:<br/>Temporizador básico</p>
        <div class="fragment">
        <p style="font-style:italic">En este ejemplo estudiaremos los observables que producen eventos a intervalos regulares y cuatro nuevos operadores:</p>
        <p><code>interval</code>, <code>startWith</code>, <code>merge</code>, <code>withLatestFrom</code>
        </div>
      </section>
    
      <section>
        <h3>Ejemplo</h3>
        <p>Partimos del siguiente documento HTML:</p>
        <pre><code class="language-html" data-trim data-noescape>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Contador&lt;/title&gt;
        &lt;meta charset="utf8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Contador: &lt;span id="contador"&gt;##&lt;/span&gt;&lt;/h1&gt;
        &lt;button id="iniciar"&gt;Iniciar&lt;/button&gt;
        &lt;button id="parar"&gt;Parar&lt;/button&gt;
        &lt;script src="main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;          
        </code></pre>
        <img style="border:1px solid black" src="17/Contador.png">
      </section>
      
      <section>
        <h3>El operador <code>interval</code></h3>
        <ul>
          <li>Recibe una cantidad de tiempo <code>t</code> y devuelve un observable que emite un evento cada <code>t</code> milisegundos.
                  <p style="text-align:center"><img src="17/interval.svg"></p>
          </li>
          <li>El valor emitido es un contador que se incrementa, pero no lo utilizaremos en este ejemplo.</li>
        </ul>        
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <pre><code class="language-javascript" data-trim data-noescape>
          const contador$ = interval(1000).pipe(
              scan(ac => ac + 1, 0)
          );          
          contador$.subscribe(c => textoContador.innerText = `${c}`);
        </code></pre>
        <p><img src="17/contador1.svg"></p>
      </section>
      
      <section>
        <h3>El operador <code>startWith</code></h3>
        <ul>
          <li>Dado un observable, produce otro igual, pero añadiendo al inicio el valor pasado como parámetro.</li>
        </ul>
        <p><img src="17/startWith.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <div style="display:flex">
          <div style="width:50%;margin-top:2em">
          <pre><code class="language-javascript" data-trim data-noescape>
            const contador$ = interval(1000)
                .pipe(
                    scan(ac => ac + 1, 0),
                    startWith(0)
                );          
          </code></pre>
          </div>
          <div>
          <p><img src="17/contador2.svg"></p>
          </div>
        </div>
      </section>
      
      <section>
        <h3>Inicio y parada del contador</h3>
        <ul style="width:95%">
          <li>Creamos un observable para cada botón:
          <ul>
            <li>El botón <em>Iniciar</em> emite valores <code>true</code>.</li>
            <li>El botón <em>Parar</em> emite valores <code>false</code>.</li>
          </ul>
          <pre class="fragment"><code class="language-javascript" data-trim data-noescape>
const ini$ = fromEvent(botonIniciar, 'click').pipe(map(() => true));
const fin$ = fromEvent(botonParar, 'click').pipe(map(() => false));
          </code></pre>
          </li>
          <li class="fragment">Mezclando ambos, obtenemos un observable que indica si el incremento está activo o inactivo:
          <pre><code class="language-javascript" data-trim data-noescape>
            const activo$ = merge(ini$, fin$).pipe(startWith(false));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>merge()</code></h3>
        <img src="17/contador3.svg">
      </section>
      
      <section>
        <h3>Habilitar y deshabilitar botones</h3>
        <ul>
          <li>Cada vez que <code>activo$</code> emite un valor, podemos actualizar la interfaz para habilitar y deshabilitar los botones:
          <pre><code class="language-javascript" data-trim data-noescape>
activo$.subscribe(act => {
    botonIniciar.disabled = act;
    botonParar.disabled = !act;
});

          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>¿Cuándo incrementar el contador?</h3>
          <pre><code class="language-javascript" data-trim data-noescape>
            const contador$ = interval(1000)
                .pipe(
                    scan(ac => ac + 1, 0),
                    startWith(0)
                );          
          </code></pre>
        <ul>
          <li>De momento, nuestro contador se incrementa con cada evento <code>interval</code>.</li>
          <li class="fragment">En realidad solo hemos de incrementarlo si, en el momento de producirse el evento <code>interval</code> , el último valor emitido por el observable <code>activo$</code> es <code>true</code>.</li>
        </ul>        
      </section>
      
      <section>
        <h3>Operador <code>withLatestFrom</code></h3>
        <ul>
          <li>Dado dos observables <code>o1</code> y <code>o2</code>, produce los valores emitidos por <code>o1</code>, cada uno de ellos asociado al último valor emitido por <code>o2</code> en ese momento:</li>
          <p><img src="17/withLatestFrom.svg"></p>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>En nuestro caso, queremos combinar los valores del observable producido por <code>interval</code> con los últimos valores emitidos por el observable <code>activo$</code>.</li>
        </ul>
        <p><img src="17/contador4.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Una vez hecha esta combinación, modificamos la función pasada a <code>scan</code> para que solo incremente el contador si el último valor emitido por <code>activo$</code> es <code>true</code>:</li>
        </ul>
        <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = interval(1000).pipe(
    withLatestFrom(activo$),
    scan((ac, [_, activo]) => activo ? ac + 1 : ac, 0),
    startWith(0)
);
        </code></pre>
      </section>    
    </section>
      
    <section>
      <section>
        <p class="info_box">Ejemplo 3:<br/>Lectura de ficheros en Node.js</p>
        <div class="fragment">
        <p style="font-style:italic">Estudiamos cómo se crean observables a partir de una colección de elementos</p>
        <p><code>of</code>, <code>from</code></p>
        
        <p style="font-style:italic">También presentamos los observables de orden superior, junto con sus operaciones asociadas.</p>
        <p><code>concatAll</code>, <code>mergeAll</code>, <code>concatMap</code>, <code>mergeMap</code>
        </div>
      </section>
      
      <section>
        <h3>Lectura de ficheros mediante observables</h3>
        <ul>
          <li>Es posible utilizar observables para gestionar otros tipos de eventos no relacionados con las acciones del usuario.</li>
          <li>Por ejemplo, podemos implementar una función <code>fromFile(filename)</code> que devuelva un observable con las líneas del fichero <code>fileName</code>.</li>
          <li class="fragment">De momento, solamente estudiaremos cómo utilizar <code>fromFile</code>. Su implementación se explicará más adelante.</li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que <code>ej1.txt</code> tiene el siguiente contenido:
        <pre><code class="no-highlight" data-trim data-noescape>
          L1
          L2
          L3
        </code></pre></li>
          <li class="fragment">La llamada a <code>fromFile("ej1.txt")</code> devuelve el siguiente observable, que emite valores a medida que se leen las líneas del fichero:</li>
        </ul>
        <p class="fragment">
          <img src="17/fromFile.svg">
        </p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Podemos utilizar este observable, por ejemplo, para leer el número de líneas del fichero:
          <pre><code class="language-javascript" data-trim data-noescape>
        fromFile('ejemplo1.txt')
            .pipe(reduce((ac, _) => ac + 1, 0))
            .subscribe(numL => console.log(`Número de líneas: ${numL}`));
          </code></pre>
          </li>
        </ul>
        <p><img src="17/numLineas.svg"></p>
      </section>
      
      
      <section>
        <h3>Creación de observables: <code>of</code> y <code>from</code></h3>
        <ul>
          <li><code>of(x1,...,xn)</code> produce un observable que emite los valores pasados como parámetro:
          <p style="text-align:center"><img src="17/of.svg"></p>
          </li>
          <li class="fragment"><code>from(xs)</code> produce un observable a partir de los elementos de un array, un objeto iterable, o una promesa:
          <p style="text-align:center"><img src="17/from.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Observables de observables</h3>
        <ul>
          <li>Es posible definir observables cuyos eventos producidos son también observables.</li>
          <li class="fragment">Por ejemplo:
          <pre><code class="language-javascript" data-trim data-noescape>
            of('F1.txt', 'F2.txt', 'F3.txt').pipe(map(f => fromFile(f)))
          </code></pre>
          </li>
        </ul>
        <p class="fragment"><img src="17/deobservables.svg" width="70%"></p>
      </section>
      
      <section>
        <h3>Observables de orden superior</h3>
        <ul>
          <li>Un observable de <strong>orden superior</strong> es aquel cuyos elementos son también observables.
          <p><img src="17/ordensuperior.svg"></p>
          </li>
          <li class="fragment">Existen operadores que transforman observables de orden superior en observables de primer orden.</li>
        </ul>
      </section>
      
      <section>
        <h3>Operador <code>concatAll()</code></h3>
        <ul>
          <li>Concatena los valores de un observable de orden superior, comenzando con los del primer observable, luego los del segundo, etc.
          <p><img src="17/concatAll.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operador <code>mergeAll()</code></h3>
        <ul>
          <li>Concatena los valores de un observable de orden superior, mezclando los valores a medida que se van produciendo por cada observable.
          <p><img src="17/mergeAll.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores <code>concatMap</code> y <code>mergeMap</code></h3>
        <ul>
          <li>Combinan el operador <code>map</code> con los dos anteriores:
          <ul>
            <li><code>concatMap(f) = map(f) + concatAll()</code></li>
            <li><code>mergeMap(f) = map(f) + mergeAll()</code></li>
          </ul>
          </li>
          <li class="fragment">Por ejemplo, si queremos sumar de la cantidad total de líneas de una serie de ficheros:
          <pre><code class="language-javascript" data-trim data-noescape>
          of('ejemplo1.txt', 'ejemplo2.txt', 'ejemplo3.txt').pipe(
              mergeMap(f => fromFile(f)),
              reduce((ac, _) => ac + 1, 0)
          ).subscribe(numL => console.log(numL));
          </code></pre>
          </li>
        </ul>
      </section>
      
    </section>


    <section>
      <section>
        <p class="info_box">Ejemplo 4:<br/>Temporizador con reinicio</p>
        <div class="fragment">
        <p style="font-style:italic">Seguimos con los observables de orden superior, y presentamos una nueva operación:</p>
        <p><code>takeUntil</code></p>
        </div>
      </section>
      
    
      <section>
        <h3>Temporizador con reinicio</h3>        
        <pre><code class="language-html" data-trim data-noescape>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Contador&lt;/title&gt;
        &lt;meta charset="utf8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Contador: &lt;span id="contador"&gt;0&lt;/span&gt;&lt;/h1&gt;
        &lt;button id="reiniciar"&gt;Reiniciar&lt;/button&gt;
        &lt;script src="main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;          
        </code></pre>
        <img style="border:1px solid black" src="17/ContadorReinicio.png">
      </section>
      
      <section>
        <h3>El operador <code>takeUntil</code></h3>
        <ul>
          <li>Dados dos observables <code>o1</code> y <code>o2</code>, devuelve un observable que emite los mismos valores de <code>o1</code>, pero solo hasta que <code>o2</code> emite su primer evento.</li>
        </ul>
        <p><img src="17/takeUntil.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Creamos una función <code>contadorHasta</code> que emite un observable con un contador que se incrementa cada segundo hasta que el observable pasado como parámetro emita un evento:</li>
          <pre><code class="language-javascript" data-trim data-noescape>
function contadorHasta(parada$) {
    return interval(1000).pipe(
        takeUntil(parada$),
        scan(ac => ac + 1, 0),
        startWith(0)
    )
}            
          </code></pre>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <img src="17/contador5.svg" width="55%">
      </section>
      
      <section>
        <h3>Contador con reinicio</h3>
        <ul>
          <li>Si <code>reini$</code> es el observable que representa las pulsaciones del botón <em>Reiniciar</em>, podemos transformar cada pulsación en un observable que representa la evolución del contador:</li>
          
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    map(() => contadorHasta(reini$)),
    concatAll()
) // También podría haberse utilizado concatMap
          </code></pre>          
        </ul>
      </section>
      
      <section>
        <h3>Temporizador con reinicio</h3>
        <p><img src="17/contador6.svg"></p>
      </section>
      
      
      <section>
        <h3>Temporizador con reinicio</h3>
        <ul>
          <li>Para hacer que el contador se inicie automáticamente, añadimos un valor ficticio al principio de nuestro observable <code>reini$</code>:</li>
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    startWith(true),  // Cualquier otro valor distinto de 'true' sirve,
                      // porque no lo utilizamos en el 'map'
    map(() => contadorHasta(reini$)),
    concatAll()
)
          </code></pre>
          o bien:
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    startWith(true),
    concatMap(() => contadorHasta(reini$)),
)            
          </code></pre>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>switchAll</code></h3>
        <ul>
          <li>Aplana un observable de orden superior, finalizando automáticamente un observable cuando comienza el siguiente.</li>
        </ul>
        <p><img src="17/switchAll.svg" width="70%"></p>
      </section>
      
      <section>
        <h3>Temporizador con reinicio</h3>
        <ul>
          <li>Con esto podemos simplificar el temporizador anterior, eliminando la necesidad de utilizar <code>takeUntil</code>:
          <pre><code class="language-javascript" data-trim data-noescape>
function contador() {
  return interval(1000).pipe(scan(ac => ac + 1, 0), startWith(0));
}            

const contador$ = reini$.pipe(
  startWith(true),
  map(() => contador()),
  switchAll()
);
          </code></pre></li>
        <li>o bien,
        <pre><code class="language-javascript" data-trim data-noescape>
  const contador$ = reini$.pipe(
    startWith(true),
    switchMap(() => contador())
  );        
        </code></pre></li>
        </ul>        
      </section>
    </section>
    
    
    
    
    
    <section>
      <section>
        <h2>Resumen de operadores</h2>
      </section>
      
      
      <section>
        <h3>Funciones de creación</h3>
        <table>
          <tr>
            <th></th>
            <th>Doc.</th>
            <th>Diag.</th>
          </tr>
          <tr>
            <td><code>fromEvent</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/fromEvent">[+]</a></td>
            <td style="text-align:center"></td>
          </tr>
          <tr>
            <td><code>interval</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/interval">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#interval">[+]</a></td>
          </tr>
          <tr>
            <td><code>of</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/of">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#of">[+]</a></td>
          </tr>
          <tr>
            <td><code>from</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/from">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#from">[+]</a></td>
          </tr>
        </table>
      </section>

      <section>
        <h3>Operadores de transformación</h3>
        <table>
          <tr>
            <th></th>
            <th>Doc.</th>
            <th>Diag.</th>
          </tr>
          <tr>
            <td><code>map</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/map">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#map">[+]</a></td>
          </tr>
          <tr>
            <td><code>filter</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/filter">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#filter">[+]</a></td>
          </tr>
          <tr>
            <td><code>take</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/take">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#take">[+]</a></td>
          </tr>
          <tr>
            <td><code>reduce</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/reduce">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#reduce">[+]</a></td>
          </tr>
          <tr>
            <td><code>scan</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/scan">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#scan">[+]</a></td>
          </tr>
          <tr>
            <td><code>startWith</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/startWith">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#startWith">[+]</a></td>
          </tr>
          <tr>
            <td><code>takeUntil</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/takeUntil">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#takeUntil">[+]</a></td>
          </tr>
        </table>
      </section>
      
      <section>
        <h3>Operadores de combinación</h3>
        <table>
          <tr>
            <th></th>
            <th>Doc.</th>
            <th>Diag.</th>
          </tr>
          <tr>
            <td><code>zip</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/zip">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#zip">[+]</a></td>
          </tr>
          <tr>
            <td><code>merge</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/merge">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#merge">[+]</a></td>
          </tr>
          <tr>
            <td><code>withLatestFrom</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/withLatestFrom">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#withLatestFrom">[+]</a></td>
          </tr>
        </table>
      </section>
      
      <section>
        <h3>Operadores sobre observables de orden superior</h3>
        <table>
          <tr>
            <th></th>
            <th>Doc.</th>
            <th>Diag.</th>
          </tr>
          <tr>
            <td><code>concatAll</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/concatAll">[+]</a></td>
            <td style="text-align:center"></td>
          </tr>
          <tr>
            <td><code>mergeAll</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/mergeAll">[+]</a></td>
            <td style="text-align:center"></td>
          </tr>
          <tr>
            <td><code>switchAll</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/switchAll">[+]</a></td>
            <td style="text-align:center"></td>
          </tr>
          <tr>
            <td><code>concatMap</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/concatMap">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#concatMap">[+]</a></td>
          </tr>
          <tr>
            <td><code>mergeMap</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/mergeMap">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#mergeMap">[+]</a></td>
          </tr>
          <tr>
            <td><code>switchMap</code></td>
            <td style="text-align:center"><a href="https://rxjs.dev/api/index/function/switchMap">[+]</a></td>
            <td style="text-align:center"><a href="https://rxmarbles.com/#switchMap">[+]</a></td>
          </tr>
        </table>
      </section>
      
      <section>
        <h3>Recursos útiles</h3>
        <ul>
          <li>Referencia de operadores RxJS:<br/>
          <a href="https://rxjs.dev/api">https://rxjs.dev/api</a>
          </li>
          <li>Árbol de decisión de operadores RxJS:<br/>
          <a href="https://rxjs.dev/operator-decision-tree">https://rxjs.dev/operator-decision-tree</a>
          </li>
          <li>Diagramas de canicas interactivos:<br/>
          <a href="https://rxmarbles.com/">https://rxmarbles.com/</a>
          </li>
        </ul>
        <p>¡Hay más de 70 operadores!</p>
      </section>
    </section>
    

        <section>
            <h2>Bibliografía</h2>
            <div style="float:left; width:70%">
                <ul>
                    <li>RxJS
                        <br>
                        <a href="https://rxjs.dev/">Documentación oficial</a><br>
                        <span style="font-size:50%">https://rxjs.dev/</span>
                    </li>

                    <li>André Staltz<br>
                        <a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you've been missing</a><br>
                        <span style="font-size:50%">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</span>
                    </li>

                    <li>
                      Sergi Mansilla<br/>
                      <a href="https://ucm.on.worldcat.org/oclc/1345473207">Reactive Programming with RxJS 5</a><br/>
                        <span style="font-size:50%">https://ucm.on.worldcat.org/oclc/1345473207</span>
                    </li>
                </ul>
            </div>
            <div style="float:right; width: 30%">
                <img src="https://rxjs.dev/generated/images/marketing/home/Rx_Logo-512-512.png" style="width:50%; border:none"><br/>
                <img src="https://coverart.oclc.org/ImageWebSvc/oclc/+-+2578290986_140.jpg?SearchOrder=+-+IG,OT,OS,AV,FA,GO&DefaultImage=N&client&allowDefault=true" style="width:50%; border:1px solid black">
            </div>
        </section>        
    
    </div>

    
    
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealHighlight, RevealNotes ]
			});
      Reveal.configure({ pdfSeparateFragments: false });
		</script>
	</body>
</html>
