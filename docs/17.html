<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Introducción a la programación reactiva con RxJS</title>

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nunito" />
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/pdap.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/nnfx-light.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
      
      <section data-background-image="img/RedBackground.jpg">
        <div style="background-color:white;height:1em"></div>
        <h1 style="color:white;font-size:240%">Introducción a la programación reactiva con RxJS</h1>
        <div style="background-color:white;height:1em"></div>

        <div style="display:flex;justify-content:space-around;align-items:center;text-align:right">
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span>Manuel Montenegro Montes</span><br>
          <span><a href="montenegro@fdi.ucm.es" style="color:#ff9999">montenegro@fdi.ucm.es</a></span><br>           </div>
          
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span><b>Programación Declarativa Aplicada</b></span><br>
          <span>Máster en Ingeniería Informática</span><br>
          <span>Facultad de Informática</span><br>
          <span>Universidad Complutense de Madrid</span><br>
          </div>            
        </div>

      </section>

        
      
      <section data-background-image="img/RedBackground.jpg" data-background-transition="fade">
          <ol class="contenidos">
            <li></li>
          </ol>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <p>Comenzamos con la siguiente página HTML:</p>
        <div style="display:flex">
          <div style="width:50%"><p><code>index.html</code></p>
            <pre style="font-size:40%"><code class="language-html" data-trim data-noescape>
    &lt;!DOCTYPE html&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;Captura de eventos&lt;/title&gt;
            &lt;link rel="stylesheet" href="index.css"/&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="areaClicks"&gt;&lt;/div&gt;
            &lt;script src="main.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;          
            </code></pre>
          </div>
          <div style="width:50%"><p><code>index.css</code></p>
            <pre style="font-size:40%"><code class="language-css" data-trim data-noescape>    
#areaClicks {
    width: 600px;
    height: 300px;
    background-color: lightblue;
}          
            </code></pre>
            <img src="17/Ventana1.png" width="80%">            
          </div>          
        </div>
      </section>

      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Ya en JavaScript, obtenemos una referencia al elemento DOM correspondiente al área sombreada <code>&lt;div&gt;</code> de la página:
          <pre><code class="language-javascript" data-trim data-noescape>
            const area = document.getElementById('areaClicks');
          </code></pre>
          </li>
        </ul>
      </section>
      
      
      <section>
        <h3>Detección de pulsaciones</h3>
        <ul>
          <li>Construimos un observable a partir de las pulsaciones de ratón realizadas sobre el área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape data-line-numbers="1,4">
import { fromEvent } from 'rxjs';

const area = document.getElementById('areaClicks');
const click$ = fromEvent(area, 'click');            
          </code></pre>
          <p style="text-align:center"><img src="17/clicks1.svg"></p>
          </li>
          <li>Por convenio, los nombres de las variables que contienen observables finalizan en <code>$</code>.</li>
          
        </ul>
      </section>
      
      <section>
        <h3>El método <code>fromEvent</code></h3>
        <ul>
          <li><code>fromEvent(e, type)</code><br/>
          Construye un observable a partir de los eventos de tipo <code>type</code> que se producen en el elemento <code>e</code> de la página.
          </li>
          <li>Cada elemento del observable creado es un objeto de la interfaz <code>Event</code> de JavaScript.</li>
        </ul>
      </section>
      
      
      <section>
        <h3>Suscripción a un observable</h3>
        <p style="text-align:center;margin:0px"><img src="17/clicks1.svg"></p>
        <ul>
          <li>Mediante el método <code>subscribe()</code> de los observables, podemos indicar las acciones a realizar cada vez que se produce un evento en <code>click$</code>:
          <pre><code class="language-javascript" data-trim data-noescape>
click$.subscribe((click) => console.log('Click! ', click));
          </code></pre>
          </li>
          <li>La función pasada a <code>subscribe()</code> recibe el objeto <code>MouseEvent</code> correspondiente a cada pulsación.</li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores RxJS</h3>
        <ul>
          <li>Permiten transformar un observable en otro.</li>
          <li>Son operaciones puras: generan un nuevo observable sin alterar el original</li>
          <li>Para aplicar una secuencia de operadores a un observable se utiliza el método <code>pipe()</code>:
          <pre><code class="language-javascript" data-trim data-noescape>
            const destino$ = origen$.pipe(
                operacion1(),
                operacion2(),
                ...
            )
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores RxJS</h3>
        <img src="17/operadores.svg" width="50%">
      </section>
      
      <section>
        <h3>El operador <code>map</code></h3>
        <ul>
          <li>Produce un observable aplicando una función a cada elemento del observable original.         
          </li>          
        </ul>
        <p><img src="17/map.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Obtenemos un observable con las coordenadas cada pulsación del ratón:
          <pre><code class="language-javascript" data-trim data-noescape>
            import { fromEvent, map } from 'rxjs';
            ...
            const click$ = fromEvent(area, 'click').pipe(
                map(evt => ({x: evt.offsetX, y: evt.offsetY}))
            );
            
            click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <img src="17/clicks2.svg">
      </section>
      
      
      <section>
        <h3>El operador <code>filter</code></h3>
        <ul>
          <li>Produce un observable a partir de los eventos de otro, para los que la función booleana pasada como parámetro devuelve true.</li>
        </ul>
        <p><img src="17/filter.svg"></p>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que solo queremos informar de las pulsaciones de ratón que se producen en la mitad izquierda del área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter } from 'rxjs';
...
const click$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    <span class="hl">filter(({x, y}) => x < area.clientWidth / 2)</span>
);

click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>take</code></h3>
        <ul>
          <li>Aplicado a un número <code>n</code>, produce un observable con los <code>n</code> primeros valores del observable inicial.</li>
        </ul>
        <p><img src="17/take.svg"></p>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Modificamos el ejemplo anterior para capturar solamente las diez primeras pulsaciones del ratón.</li>
        </ul>
        <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter, take } from 'rxjs';
...
const click$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    filter(({x, y}) => x < area.clientWidth / 2),
    <span class="hl">take(10)</span>
);

click$.subscribe(({x, y}) => console.log(`Click en (${x},${y})`));
        </code></pre>
      </section>
        
      <section>
        <h3>El operador <code>reduce</code></h3>
        <ul>
          <li>Similar a la función <code>reduce</code> de JavaScript.</li>
          <li>Mantiene un acumulador que se actualiza a medida que el observable origen produce valores.</li>
          <li>Cuando el observable origen finaliza, se emite el valor final del acumulador.</li>
        </ul>
        <p><img src="17/reduce.svg"></p>
      </section>
      
      <section>
        <h3>El operador <code>scan</code></h3>
        <ul>
          <li>Similar a <code>reduce</code>, pero el observable resultante emite los valores intermedios del acumulador.</li>
        </ul>
        <img src="17/scan.svg">
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que queremos contar el número de pulsaciones de ratón sobre el área sombreada:
          <pre><code class="language-javascript" data-trim data-noescape>
import { fromEvent, map, filter, take, scan } from 'rxjs';
...

const click$ = fromEvent(area, 'click');
const cont$ = click$.pipe(scan((ac, _) => ac + 1, 0));

cont$.subscribe(cont => console.log(`Contador: ${cont}`));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>zip</code></h3>
        <ul>
          <li>Combina varios observables en uno solo.</li>
          <li>Cada valor del resultado es una agrupación formada a partir de los valores emitidos por cada observable.</li>
        </ul>
        <p><img src="17/zip.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Combinamos los dos observables anteriores:
          <ul>
            <li><code>coord$</code>: coordenadas de cada pulsación</li>
            <li><code>cont$</code>: número de pulsaciones</li>
          </ul>          
          </li>
        </ul>
        <p><img src="17/clicks3.svg" width="60%"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <pre><code class="language-javascript" data-trim data-noescape>

import { fromEvent, map, filter, take, scan, zip } from 'rxjs';

const area = document.getElementById('areaClicks');

const coord$ = fromEvent(area, 'click').pipe(
    map(evt => ({x: evt.offsetX, y: evt.offsetY})),
    filter(({x, y}) => x < area.clientWidth / 2)
);

const cont$ = coord$.pipe(scan((ac, _) => ac + 1, 0));

zip(coord$, cont$)
    .pipe(take(10))
    .subscribe(([{x, y}, cont]) => {
        console.log(`Pulsación en (${x}, ${y}) / contador = ${cont}`);
    });
        </code></pre>
      </section>
      
      
      <section>
        <h3>Lectura de ficheros mediante observables</h3>
        <ul>
          <li>Es posible utilizar observables para gestionar otros tipos de eventos, no necesariamente relacionados con las interfaces gráficas de usuario.</li>
          <li>Por ejemplo, podemos implementar una función <code>fromFile(filename)</code> que devuelva un observable con las líneas del fichero <code>fileName</code>.</li>
          <li>De momento, solamente veremos cómo utilizar <code>fromFile</code>. Su implementación se explicará más adelante.</li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Supongamos que <code>ej1.txt</code> tiene el siguiente contenido:
        <pre><code class="no-highlight" data-trim data-noescape>
          L1
          L2
          L3
        </code></pre></li>
          <li>La llamada a <code>fromFile("ej1.txt")</code> devuelve el siguiente observable, que emite valores a medida que se leen las líneas del fichero:</li>
        </ul>
        <p>
          <img src="17/fromFile.svg">
        </p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Podemos utilizar este observable, por ejemplo, para leer el número de líneas del fichero:
          <pre><code class="language-javascript" data-trim data-noescape>
        fromFile('ejemplo1.txt')
            .pipe(reduce((ac, _) => ac + 1, 0))
            .subscribe(numL => console.log(`Número de líneas: ${numL}`));
          </code></pre>
          </li>
        </ul>
        <p><img src="17/numLineas.svg"></p>
      </section>
      
      
      <section>
        <h3>Creación de observables: <code>of</code> y <code>from</code></h3>
        <ul>
          <li><code>of(x1,...,xn)</code> produce un observable que emite los valores pasados como parámetro:
          <p style="text-align:center"><img src="17/of.svg"></p>
          </li>
          <li><code>from(xs)</code> produce un observable a partir de los elementos de un array, un objeto iterable, o una promesa:
          <p style="text-align:center"><img src="17/from.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Observables de observables</h3>
        <ul>
          <li>Es posible definir observables cuyos eventos producidos son también observables.</li>
          <li>Por ejemplo:
          <pre><code class="language-javascript" data-trim data-noescape>
            of('F1.txt', 'F2.txt', 'F3.txt').pipe(map(f => fromFile(f)))
          </code></pre>
          </li>
        </ul>
        <p><img src="17/deobservables.svg" width="70%"></p>
      </section>
      
      <section>
        <h3>Observables de orden superior</h3>
        <ul>
          <li>Un observable de <strong>orden superior</strong> es aquel cuyos elementos son también observables.
          <p><img src="17/ordensuperior.svg"></p>
          </li>
          <li>Existen operadores que transforman observables de orden superior en observables de primer orden.</li>
        </ul>
      </section>
      
      <section>
        <h3>Operador <code>concatAll()</code></h3>
        <ul>
          <li>Concatena los valores de un observable de orden superior, comenzando con los del primer observable, luego los del segundo, etc.
          <p><img src="17/concatAll.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operador <code>mergeAll()</code></h3>
        <ul>
          <li>Concatena los valores de un observable de orden superior, mezclando los valores a medida que se van produciendo por cada observable.
          <p><img src="17/mergeAll.svg"></p>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Operadores <code>concatMap</code> y <code>mergeMap</code></h3>
        <ul>
          <li>Combinan el operador <code>map</code> con los dos anteriores:
          <ul>
            <li><code>concatMap(f) = map(f) + concatAll()</code></li>
            <li><code>mergeMap(f) = map(f) + mergeAll()</code></li>
          </ul>
          </li>
          <li>Por ejemplo, si queremos sumar de la cantidad total de líneas de una serie de ficheros:
          <pre><code class="language-javascript" data-trim data-noescape>
          of('ejemplo1.txt', 'ejemplo2.txt', 'ejemplo3.txt').pipe(
              mergeMap(f => fromFile(f)),
              reduce((ac, _) => ac + 1, 0)
          ).subscribe(numL => console.log(numL));
          </code></pre>
          </li>
        </ul>
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <p>Partimos del siguiente documento HTML:</p>
        <pre><code class="language-html" data-trim data-noescape>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Contador&lt;/title&gt;
        &lt;meta charset="utf8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Contador: &lt;span id="contador"&gt;##&lt;/span&gt;&lt;/h1&gt;
        &lt;button id="iniciar"&gt;Iniciar&lt;/button&gt;
        &lt;button id="parar"&gt;Parar&lt;/button&gt;
        &lt;script src="main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;          
        </code></pre>
        <img style="border:1px solid black" src="17/Contador.png">
      </section>
      
      <section>
        <h3>El operador <code>interval</code></h3>
        <ul>
          <li>Recibe una cantidad de tiempo <code>t</code> y devuelve un observable que emite un evento cada <code>t</code> milisegundos.
                  <p style="text-align:center"><img src="17/interval.svg"></p>
          </li>
          <li>El valor emitido es un contador que se incrementa, pero no lo utilizaremos en este ejemplo.</li>
        </ul>        
      </section>
      
      
      <section>
        <h3>Ejemplo</h3>
        <pre><code class="language-javascript" data-trim data-noescape>
          const contador$ = interval(1000).pipe(
              scan(ac => ac + 1, 0)
          );          
          contador$.subscribe(c => textoContador.innerText = `${c}`);
        </code></pre>
        <p><img src="17/contador1.svg"></p>
      </section>
      
      <section>
        <h3>El operador <code>startWith</code></h3>
        <ul>
          <li>Dado un observable, produce otro igual, pero añadiendo un evento al inicio.</li>
        </ul>
        <p><img src="17/startWith.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <div style="display:flex">
          <div style="width:50%;margin-top:2em">
          <pre><code class="language-javascript" data-trim data-noescape>
            const contador$ = interval(1000)
                .pipe(
                    scan(ac => ac + 1, 0),
                    startWith(0)
                );          
          </code></pre>
          </div>
          <div>
          <p><img src="17/contador2.svg"></p>
          </div>
        </div>
      </section>
      
      <section>
        <h3>Inicio y parada del contador</h3>
        <ul style="width:100%">
          <li>Creamos un observable para cada botón:
          <ul>
            <li>El botón <em>Iniciar</em> emite valores <code>true</code>.</li>
            <li>El botón <em>Parar</em> emite valores <code>false</code>.</li>
          </ul>
          <pre><code class="language-javascript" data-trim data-noescape>
const ini$ = fromEvent(botonIniciar, 'click').pipe(map(() => true));
const fin$ = fromEvent(botonParar, 'click').pipe(map(() => false));
          </code></pre>
          </li>
          <li>Mezclando ambos, obtenemos un observable que nos dice si el incremento está activo o inactivo:
          <pre><code class="language-javascript" data-trim data-noescape>
            const activo$ = merge(ini$, fin$).pipe(startWith(false));
          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>El operador <code>merge()</code></h3>
        <img src="17/contador3.svg">
      </section>
      
      <section>
        <h3>Habilitar y deshabilitar botones</h3>
        <ul>
          <li>Cada vez que se emite un evento en <code>activo$</code>, podemos actualizar la interfaz para habilitar y deshabilitar los botones:
          <pre><code class="language-javascript" data-trim data-noescape>
activo$.subscribe(act => {
    botonIniciar.disabled = act;
    botonParar.disabled = !act;
});

          </code></pre>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>¿Cuándo incrementar el contador?</h3>
          <pre><code class="language-javascript" data-trim data-noescape>
            const contador$ = interval(1000)
                .pipe(
                    scan(ac => ac + 1, 0),
                    startWith(0)
                );          
          </code></pre>
        <ul>
          <li>De momento, nuestro contador se incrementa con cada evento <code>interval</code>.</li>
          <li>En realidad solo hemos de incrementarlo si, en el momento de producirse el evento, el último valor emitido por el observable <code>activo$</code> es <code>true</code>.</li>
        </ul>        
      </section>
      
      <section>
        <h3>Operador <code>withLatestFrom</code></h3>
        <ul>
          <li>Dado dos observables <code>o1</code> y <code>o2</code>, produce cada uno de los valores emitidos por <code>o1</code> asociado al último valor emitido por <code>o2</code> en ese momento:</li>
          <p><img src="17/withLatestFrom.svg"></p>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>En nuestro caso, queremos combinar los valores del observable producido por <code>interval</code> con los últimos valores emitidos por el observable <code>activo$</code>.</li>
        </ul>
        <p><img src="17/contador4.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Una vez hecha esta combinación, modificamos la función pasada a <code>scan</code> para que solo incremente el contador si el último valor emitido por <code>activo$</code> es <code>true</code>:</li>
        </ul>
        <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = interval(1000).pipe(
    withLatestFrom(activo$),
    scan((ac, [_, activo]) => activo ? ac + 1 : ac, 0),
    startWith(0)
);
        </code></pre>
      </section>
      
      <section>
        <h3>Contador con reinicio</h3>        
        <pre><code class="language-html" data-trim data-noescape>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Contador&lt;/title&gt;
        &lt;meta charset="utf8"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Contador: &lt;span id="contador"&gt;0&lt;/span&gt;&lt;/h1&gt;
        &lt;button id="reiniciar"&gt;Reiniciar&lt;/button&gt;
        &lt;script src="main.js"&gt;&lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;          
        </code></pre>
        <img style="border:1px solid black" src="17/ContadorReinicio.png">
      </section>
      
      <section>
        <h3>El operador <code>takeUntil</code></h3>
        <ul>
          <li>Dados dos observables <code>o1</code> y <code>o2</code>, devuelve un observable que emite los mismos valores de <code>o1</code>, pero solo hasta que <code>o2</code> emite su primer evento.</li>
        </ul>
        <p><img src="17/takeUntil.svg"></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Creamos una función <code>contadorHasta</code> que emite un observable con un contador que se incrementa cada segundo hasta que el observable pasado como parámetro emita un evento:</li>
          <pre><code class="language-javascript" data-trim data-noescape>
function contadorHasta(parada$) {
    return interval(1000).pipe(
        takeUntil(parada$),
        scan(ac => ac + 1, 0),
        startWith(0)
    )
}            
          </code></pre>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <img src="17/contador5.svg" width="60%">
      </section>
      
      <section>
        <h3>Contador con reinicio</h3>
        <ul>
          <li>Si <code>reini$</code> es el observable que representa las pulsaciones del botón <em>Reiniciar</em>, podemos transformar cada pulsación en un observable que representa la evolución del contador:</li>
          
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    map(() => contadorHasta(reini$)),
    concatAll()
) // También podría haberse utilizado concatMap
          </code></pre>          
        </ul>
      </section>
      
      <section>
        <h3>Contador con reinicio</h3>
        <p><img src="17/contador6.svg"></p>
      </section>
      
      
      <section>
        <h3>Contador con reinicio</h3>
        <ul>
          <li>Para hacer que el contador se inicie automáticamente, añadimos un valor ficticio al principio de nuestro observable <code>reini$</code>:</li>
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    startWith(true),  // Cualquier otro valor distinto de 'true' sirve,
                      // porque no lo utilizamos en el 'map'
    map(() => contadorHasta(reini$)),
    concatAll()
)
          </code></pre>
          o bien:
          <pre><code class="language-javascript" data-trim data-noescape>
const contador$ = reini$.pipe(
    startWith(true),
    concatMap(() => contadorHasta(reini$)),
)            
          </code></pre>
        </ul>
      </section>
    
    </div>

    
    
		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealHighlight, RevealNotes ]
			});
      Reveal.configure({ pdfSeparateFragments: false });
		</script>
	</body>
</html>
