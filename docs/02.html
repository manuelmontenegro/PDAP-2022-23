<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nunito" />
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/pdap.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/nnfx-light.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
      
      <section data-background-image="img/RedBackground.jpg">
        <div style="background-color:white;height:1em"></div>
        <h1 style="color:white">Introducción a Kotlin</h1>
        <div style="background-color:white;height:1em"></div>

        <div style="display:flex;justify-content:space-around;align-items:center;text-align:right">
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span>Manuel Montenegro Montes</span><br>
          <span><a href="montenegro@fdi.ucm.es" style="color:#ff9999">montenegro@fdi.ucm.es</a></span><br>           </div>
          
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span><b>Programación Declarativa Aplicada</b></span><br>
          <span>Máster en Ingeniería Informática</span><br>
          <span>Facultad de Informática</span><br>
          <span>Universidad Complutense de Madrid</span><br>
          </div>            
        </div>

      </section>

      
      <section data-background-image="img/RedBackground.jpg" data-background-transition="fade">
          <ol class="contenidos">
            <li></li>
          </ol>
      </section>
      
      <section>
        <h3>¿Qué es la programación funcional?</h3>
        <ul>
          <li>Es el paradigma de programación basado en la definición y aplicación de funciones.</li>
          <li>En la programación funcional <em>pura</em>, las funciones se consideran en el estricto sentido matemático:
          <ul>
            <li>Una función <em class="rojo">f: X &rarr; Y</em> asigna a cada elemento de <em>X</em> un único valor de <em>Y</em>.</li>
            <li>Es decir, la aplicación de función <em>f(x)</em> depende exclusivamente de <em>x</em>.</li>
          </ul>
          </li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplos</h3>
        
        <pre><code class="language-kotlin" data-trim data-noescape>
        fun suma(x: Int, y: Int) = x + y    <span class="arrow_box_left fragment">Función pura</span>
        <span class="fragment">// El valor devuelto depende únicamente de los parámetros</span>

        var x: Int = 0;
        fun incrementar(y: Int): Int {      <span class="arrow_box_left fragment">No es función pura</span>
            x += y            <span class="fragment">// &larr; Produce un efecto lateral</span>
            return x
        }

        fun obtenerLista(nombreFich: String): List<String> =   <span class="arrow_box_left fragment">No es función pura</span>
            File(nombreFich).readLines()  <span class="fragment">// No solo depende del nombre del
                                          // fichero sino también del contenido</span>
        </code></pre>
      </section>
      
      <section data-transition="none-out">
        <h3>¿Qué ventaja tienen las funciones puras?</h3>
        <ul>
          <li><strong>Transparencia referencial:</strong> Toda expresión depende únicamente de los valores de las variables que contiene.</li>          
          <li>Es más fácil razonar sobre el comportamiento de una función en ausencia de efectos laterales.</li>
        </ul>
        <p class="fragment"><strong>Son equivalentes:</strong></p>
          <div style="float:left;width:50%">
            <pre><code class="language-kotlin" style="font-size:large" data-trim data-noescape>
              val z = 5
              print("${suma(z, 1)} = ${suma(z, 1)}")
            </code></pre>
          </div>
          <div style="float:right;width:50%"  >
            <pre><code class="language-kotlin" style="font-size:large" data-trim data-noescape>
              val z = 5
              val s = suma(z, 1)
              print("$s = $s")
            </code></pre>
          </div>        
      </section>

      <section data-transition="none-in">
        <h3>¿Qué ventaja tienen las funciones puras?</h3>
        <ul>
          <li><strong>Transparencia referencial:</strong> Toda expresión depende únicamente de los valores de las variables que contiene.</li>          
          <li>Es más fácil razonar sobre el comportamiento de una función en ausencia de efectos laterales.</li>
        </ul>
        <p><strong>No son equivalentes:</strong></p>
          <div style="float:left;width:50%">
            <pre><code class="language-kotlin" style="font-size:large" data-trim data-noescape>
              print(
                "${incrementar(3)} = ${incrementar(3)}"
              )
            </code></pre>
          </div>
          <div style="float:right;width:50%"  >
            <pre><code class="language-kotlin" style="font-size:large" data-trim data-noescape>
              val s = incrementar(3)
              print("$s = $s")
            </code></pre>
          </div>        
      </section>
      
      <section>
        <h3>¿Qué ventaja tienen las funciones puras?</h3>
        <ul>
          <li>Es más fácil razonar sobre ellas.</li>
          <li>Son más fáciles de testear.</li>
          <li>Son más fáciles de reutilizar.</li>
          <li>Son más fáciles de paralelizar.</li>
        </ul>
        <p class="rojo fragment" style="font-style:italic">¡Muchos menos <em>bugs</em>!</p>
      </section>
      
      <section>
        <h3>Características de los lenguajes funcionales</h3>
        <ul>
          <li>Las funciones son <strong>ciudadanas de primera clase</strong>.
          <ul>
            <li>Se comportan como cualquier otro valor del lenguaje.</li>
            <li>Podemos pasar funciones como parámetro, almacenarlas en variables, devolver funciones como resultado, etc.</li>
          </ul></li>
          <li>Fomentan o imponen la <strong>inmutabilidad</strong>.
          <ul>
            <li>No es posible cambiar el valor de una variable o de una estructura de datos.</li>
            <li>Permite compartición de estructuras de datos sin riesgo de <em>bugs</em></li>
          </ul>
          </li>
          <li>Limitan o encapsulan los <strong>efectos laterales</strong>.</li>
          <li>Utilizan <strong>recursión</strong> en lugar de bucles.
        </ul>
      </section>
      
      <section>
        <h3>Recursión</h3>
        <ul>
          <li>Una función <strong>recursiva</strong> es una función que se invoca a sí misma.          
          </li>
          <li>La recursión permite expresar cómputos de manera alternativa a los bucles, pero sin mutar variables.
          <pre><code class="language-kotlin" data-trim data-noescape>
            fun factorial(n: Int): Int =
                if (n == 0) 1 else n * factorial(n - 1)
                
            println(factorial(5))  <span class="fragment"> // &rarr; 120</span>
          </code></pre>
          </li>
          <li>En Kotlin, es necesario indicar el <strong>tipo de retorno</strong> de una función recursiva.</li>
        </ul>
      </section>
      
      <section>
        <h3>Ejemplo: <code>factorial(3)</code></h3>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun factorial(n: Int): Int =
              if (n == 0) 1 else n * factorial(n - 1)
        </code></pre>
        <pre><code class="no-highlight" data-trim data-noescape>
          factorial(3)
          
          <span class="fragment">&rarr; 3 * factorial(2)</span>
          
          <span class="fragment">&rarr; 3 * (2 * factorial(1))</span>
          
          <span class="fragment">&rarr; 3 * (2 * (1 * factorial(0)))</span>   <span class="arrow_box_left fragment"> Caso base </span>
          
          <span class="fragment">&rarr; 3 * (2 * (1 * 1))</span>
          
          <span class="fragment">&rarr; 3 * (2 * 1)</span>
          
          <span class="fragment">&rarr; 3 * 2</span>
          
          <span class="fragment">&rarr; 6</span>
        </code></pre>
      </section>
      
      <section>
        <h3>Funciones recursivas sobre listas</h3>
        <p>Calcular la suma de los elementos de una lista:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
        // Suma los elementos de la lista `xs` pasada como parámetro
        // desde el situado en el índice `i` hasta el final de la lista
        
        fun sumaElemsRec(xs: List&lt;Int&gt;, i: Int): Int =
          if (i == xs.size) 0 else xs[i] + sumaElemsRec(xs, i + 1)
          
        // Suma todos los elementos de la lista `xs` pasada como parámetro

        fun sumaElems(xs: List&lt;Int&gt;) = sumaElemsRec(xs, 0) <span class="arrow_box_left fragment">Llamada inicial</span>
        </code></pre>
        <p>A menudo son necesarias funciones auxiliares con parámetros extra.</p>
      </section>
      
      <section>
        <h3>Funciones recursivas sobre listas</h3>
        <p>Estas funciones auxiliares pueden declararse localmente, para que no sean visibles desde el exterior.</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun sumaElems(xs: List&lt;Int&gt;): Int {
              // Función auxiliar
              fun sumaElemsRec(xs: List&lt;Int&gt;, i: Int): Int =
                  if (i == xs.size) 0 else xs[i] + sumaElemsRec(xs, i + 1)
              
              // Llamada inicial
              return sumaElemsRec(xs, 0)
          }
        </code></pre>
      </section>
      
      <section>
        <h3>Funciones recursivas sobre listas</h3>
        <p>El parámetro <code>xs</code> puede eliminarse de la función auxiliar, ya que está accesible en un contexto superior y se mantiene constante a lo largo de las llamadas recursivas.</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun sumaElems(xs: List&lt;Int&gt;): Int {
              // Función auxiliar
              fun sumaElemsRec(i: Int): Int =
                  if (i == xs.size) 0 else xs[i] + sumaElemsRec(i + 1)
              
              // Llamada inicial
              return sumaElemsRec(xs, 0)
          }
        </code></pre>
      </section>
      
      <section>
        <h3>Ejemplo: <code>sumaElems([5, 10, 4])</code></h3>
        <pre><code class="no-highlight" data-trim data-noescape>
          sumaElems([5, 10, 4])
          
          <span class="fragment">&rarr; sumaElemsRec(0)</span>

          <span class="fragment">&rarr; 5 + sumaElemsRec(1)</span>
          
          <span class="fragment">&rarr; 5 + (10 + sumaElemsRec(2))</span>
          
          <span class="fragment">&rarr; 5 + (10 + (4 + sumaElemsRec(3)))</span>

          <span class="fragment">&rarr; 5 + (10 + (4 + 0))</span>
          
          <span class="fragment">&rarr; 5 + (10 + 4)</span>
          
          <span class="fragment">&rarr; 5 + 14</span>
          
          <span class="fragment">&rarr; 19</span>          
        </code></pre>        
      </section>
      
      <section>
        <h3>El método <code>subList</code></h3>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.subList(fromIndex: Int, toIndex: Int): List&lt;T&gt;
        </code></pre>
        <ul>
        <li>Obtiene una sublista de <code>this</code> con los elementos comprendidos entre <code>fromIndex</code> (incluido) y <code>toIndex</code> (excluído).
        <pre><code class="language-kotlin" data-trim data-noescape>
          listOf(6, 3, 1, 5, 10, 3).subList(2, 4) // &rarr; [1, 5]
        </code></pre></li>
        </ul>
      </section>
      
      <section>
        <h3>El método <code>subList</code></h3>
        <ul>
        <li>Permite implementar recorridos sobre listas sin necesidad de pasar índices como parámetros.</li>
        </ul>
        <pre><code class="language-kotlin" data-trim data-noescape>
        fun sumaElems(xs: List<Int>): Int =
            if (xs.isEmpty()) 0 else xs[0] + sumaElems(xs.subList(1, xs.size))
        </code></pre>
      </section>
      
      <section>
        <h3>El método <code>subList</code></h3>
        <ul>
        <li>Tiene coste <em class="rojo">O(1)</em>, porque no se realiza ninguna copia del segmento obtenido; se genera una <strong>vista</strong> de la lista original.</li>
        </ul>
        <p><img src="02/subList.svg" width="40%"/></p>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
        <ul>
          <li>Dada una lista de enteros <code>xs</code>, obtener otra lista con los elementos de <code>xs</code> que no sean pares:</li>
        </ul>
        <pre><code class="language-kotlin" data-trim data-noescape>
        fun quitarPares(xs: List<Int>): List<Int> = when {
            // Lista vacía
              xs.isEmpty() -> listOf()
            // Lista cuyo primer elemento es par
              xs[0] % 2 == 0 -> quitarPares(xs.subList(1, xs.size))
            // Lista cuyo primer elemento es impar
              else -> listOf(xs[0]) + quitarPares(xs.subList(1, xs.size))
        }          
        </code></pre>
      </section>
      
      
      <section>
        <h3>Ejemplo: <code>quitarPares([3, 4, 7, 6])</code></h3>
        <pre><code class="no-highlight" data-trim data-noescape>
          quitarPares([3, 4, 7, 6])
          
          <span class="fragment">&rarr; [3] + quitarPares([4, 7, 6])</span>
          
          <span class="fragment">&rarr; [3] + quitarPares([7, 6])</span>
          
          <span class="fragment">&rarr; [3] + ([7] + quitarPares([6]))</span>
          
          <span class="fragment">&rarr; [3] + ([7] + quitarPares([]))</span>
          
          <span class="fragment">&rarr; [3] + ([7] + [])</span>
          
          <span class="fragment">&rarr; [3] + [7]</span>
          
          <span class="fragment">&rarr; [3, 7]</span>
        </code></pre>
      </section>
      
      <section>
        <h3>Ejemplo</h3>
          <p>Búsqueda lineal de un elemento en una lista:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
        
        tailrec fun &lt;T&gt; buscarElem(xs: List&lt;T&gt;, x: T): Boolean = when {
            // Lista vacía
              xs.isEmpty() -> false
            // El elemento a buscar está al principio
              xs[0] == x -> true
            // El elemento a buscar no está al principio
              else -> buscarElem(xs.subList(1, xs.size), x)
        }
        </code></pre>
      </section>

      
      <section>
        <h3>Ejemplo: <code>buscarElem([3, 4, 7, 6], 7)</code></h3>
        <pre><code class="no-highlight" data-trim data-noescape>
          buscarElem([3, 4, 7, 6], 7)
          
          &rarr; buscarElem([4, 7, 6], 7)
          
          &rarr; buscarElem([7, 6], 7)
          
          &rarr; true
        </code></pre>
      </section>      
      
      
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
      Reveal.configure({ pdfSeparateFragments: false });
		</script>
	</body>
</html>
