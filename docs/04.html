<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Estructuras de datos persistentes: listas</title>

    <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Nunito" />
		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/pdap.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/nnfx-light.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
      
      <section data-background-image="img/RedBackground.jpg">
        <div style="background-color:white;height:1em"></div>
        <h1 style="color:white;font-size:240%">Estructuras de datos persistentes: listas</h1>
        <div style="background-color:white;height:1em"></div>

        <div style="display:flex;justify-content:space-around;align-items:center;text-align:right">
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span>Manuel Montenegro Montes</span><br>
          <span><a href="montenegro@fdi.ucm.es" style="color:#ff9999">montenegro@fdi.ucm.es</a></span><br>           </div>
          
          <div style="font-size:60%;text-align:center;background-color:rgba(0,0,0,0.9);padding:10px;color:white;margin-top:1em;border-radius:10px">
          <span><b>Programaci칩n Declarativa Aplicada</b></span><br>
          <span>M치ster en Ingenier칤a Inform치tica</span><br>
          <span>Facultad de Inform치tica</span><br>
          <span>Universidad Complutense de Madrid</span><br>
          </div>            
        </div>

      </section>

        
      
      <section data-background-image="img/RedBackground.jpg" data-background-transition="fade">
          <ol class="contenidos">
            <li></li>            
          </ol>
      </section>
    
    <section>
      <h3>Inmutabilidad en programaci칩n funcional</h3>
      <ul>
        <li>Los lenguajes funcionales promueven el uso de las estructuras de datos inmutables.</li>
        <li>Hasta ahora hemos trabajado con inmutabilidad a nivel de variables (uso de <code>val</code> frente a <code>var</code>).</li>
        <li>Tambi칠n conocemos las interfaces <code>List&lt;T&gt;</code>, <code>Set&lt;T&gt;</code> y <code>Map&lt;T&gt;</code>, que representan colecciones de datos inmutables.</li>
      </ul>
    </section>
    
    <section>
      <h3>Inmutabilidad en programaci칩n funcional</h3>
      <ul>
        <li>En Kotlin se utilizan las clases de la biblioteca est치ndar de Java para implementar las interfaces <code>List&lt;T&gt;</code>, <code>Map&lt;T&gt;</code>, <code>Set&lt;T&gt;</code>.
        <ul>
        <li>Por ejemplo, la funci칩n <code>listOf()</code> devuelve un objeto de la clase <code>ArrayList</code>.</li>
        </ul>
        </li>
        <li>Estas clases no estaban inicialmente concebidas para realizar operaciones inmutables.</li>
        
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: <code>seq()</code></h3>
      <ul>
        <li>Escribimos una funci칩n <code>seq()</code> que, dados dos n칰meros <code>from</code> y <code>to</code>, construye la lista con los n칰meros comprendidos entre ambos (sin incluir <code>to</code>).
      <pre><code class="language-kotlin" data-trim data-noescape>
      fun seq(from: Int, to: Int): List&lt;Int&gt; =
          if (from >= to) 
            emptyList() 
          else 
            listOf(from) + seq(from + 1, to)
      </code></pre>
        </li>
        <li>Ejemplo de ejecuci칩n:
        <pre><code class="language-kotlin" data-trim data-noescape>
          println(seq(1, 5)) // &rarr; [1, 2, 3, 4]
        </code></pre>
        </li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: <code>seq()</code></h3>
      <pre><code class="no-highlight" data-trim data-noescape>
      seq(1, 5)
      &rarr; [1] + seq(2, 5)
      &rarr; [1] + ([2] + seq(3, 5))
      &rarr; [1] + ([2] + ([3] + seq(4, 5)))
      &rarr; [1] + ([2] + ([3] + ([4] + seq(5, 5))))
      &rarr; [1] + ([2] + ([3] + ([4] + [])))
      &rarr; [1] + ([2] + ([3] + [4]))
      &rarr; [1] + ([2] + [3, 4])
      &rarr; [1] + [2, 3, 4]
      &rarr; [1, 2, 3, 4]
      </code></pre>
    </section>
    
    <section>
      <h3>Ejemplo: <code>seq()</code></h3>
      <ul>
        <li>En la implementaci칩n de listas basada en arrays (<code>ArrayList</code>) cada vez que concatenamos dos listas, se genera un array nuevo con los elementos de ambas.
        <p style="text-align:center"><img src="04/CopiaDefensiva.svg"></p>
        </li>
        <li>La ejecuci칩n de <code>seq(0, N)</code> tiene coste <em class="rojo">O(N<sup>2</sup>)</em> 游땸</li>
      </ul>
    </section>
    
    
    <section>
      <h3>Estructuras de datos persistentes</h3>
      <ul>
        <li>Las <strong>estructuras de datos persistentes</strong> permiten implementar operaciones que preserven la estructura original, pero sin necesidad de realizar una copia previa de toda la estructura.</li>
        <li>En su lugar, construyen el resultado de la operaci칩n reutilizando parte de la estructura original.</li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: concatenaci칩n de dos listas</h3>
      <p><code>val zs = xs + ys</code></p>
      <p>Utilizando arrays:</p>
      <p><img src="04/ConcatDefensiva.svg" width="40%"></p>
    </section>
    
    <section>
      <h3>Ejemplo: concatenaci칩n de dos listas</h3>
      <p><code>val zs = xs + ys</code></p>
      <p>Utilizando listas persistentes:</p>
      <p><img src="04/ConcatPersistente.svg" width="70%"></p>
    </section>

    <section>
      <p><img src="04/ConcatPersistente.svg" width="70%"></p>
      <ul>
        <li>Al realizar la concatenaci칩n <code>xs + ys</code>, se realiza una copia de <code>xs</code>, la cual se &laquo;engancha&raquo; con <code>ys</code>.</li>
        <li>La lista <code>ys</code> forma parte de <code>zs</code>, pero <code>ys</code> sigue siendo accesible de manera independiente.</li>
      </ul>
    </section>
    
    
    <section>
      <h3>Definici칩n del tipo <code>List&lt;T&gt;</code></h3>
      <ul style="width:100%">
        <li>Definimos una clase abstracta vac칤a:
        </li>
        <pre><code class="language-kotlin" data-trim data-noescape>
                        <span class="arrow_box_down" style="position:relative;top:-5px">Tipo de los elementos</span>
          abstract class List&lt;out T&gt;
        </code></pre>
        <li>Definimos dos clases que la extienden:</li>
        <div style="display:flex">
          <div style="width:70%">
          <pre><code class="language-kotlin" data-trim data-noescape>
          object Nil : List&lt;Nothing&gt;()
          </code></pre>
          <pre><code class="language-kotlin" data-trim data-noescape>
          data class Cons&lt;T&gt;(
              val head: T, 
              val tail: List&lt;T&gt;
            ) : List&lt;T&gt;()
          </code></pre>
          </div>
          <div>
            
            <div><img src="04/ListaVacia.svg"></div>
            
            <div><img src="04/ListaNoVacia.svg"></div>
          </div>
        </div>
        
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: lista <code>[1, 2, 3]</code></h3>
      <p>쮺칩mo construimos la siguiente lista?</p>
      <p><img src="04/Lista123.svg"></p>
      <pre><code class="language-kotlin" data-trim data-noescape>
        val xs = Cons(1, Cons(2, Cons(3, Nil)))
      </code></pre>
    </section>
    
    <section>
      <h3>Examinando la definici칩n</h3>
      <ul>
        <li>El objeto <code>Nil</code> representa la lista vac칤a
        <pre><code class="language-kotlin" data-trim data-noescape>
            object Nil : List&lt;Nothing&gt;()
        </code></pre>
        </li>
        <li>Se declara como <code>object</code> porque solamente necesitamos un objeto en memoria que represente la lista vac칤a.
        </li>
        <li>El objeto tiene tipo <code>List&lt;Nothing&gt;</code>, porque <code>Nothing</code> es subtipo de cualquier otro.
        <ul>
          <li>Por tanto, <code>Nil</code> tambi칠n puede utilizarse donde se requiera un <code>List&lt;Int&gt;</code> o un <code>List&lt;String&gt;</code>.</li>
        </ul>
        <pre><code class="language-kotlin" data-trim data-noescape>
          val xs = Cons(1, Cons(2, Nil))
          val ys = Cons("Gerardo", Cons("Alicia", Nil))
        </code></pre>
        </li>
      </ul>
    </section>
    
    <section>
      <h3>Examinando la definici칩n</h3>
      <ul>
        <li>La clase <code>Cons</code> representa las listas con, al menos, un elemento.
        <pre><code class="language-kotlin" data-trim data-noescape>
        data class Cons&lt;T&gt;(val head: T, val tail: List&lt;T&gt;) : List&lt;T&gt;()        
        </code></pre>
        </li>
        <li>El primer elemento se encuentra en el atributo <code>head</code> y recibe el nombre de <strong>cabeza</strong> de la lista.</li>
        <li>El atributo <code>tail</code> representa la <strong>cola</strong> de la lista, y puede ser <code>Nil</code>, u otra instancia de <code>Cons</code>.</li>        
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: revisando la funci칩n <code>seq</code></h3>
      <ul>
        <li>Implementamos la funci칩n <code>seq</code> mediante listas persistentes:
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun seq(from: Int, to: Int): List&lt;Int&gt; =
            if (from &gt;= to) Nil else Cons(from, seq(from + 1, to))      
      </code></pre>
      <pre><code class="no-highlight" data-trim data-noescape>
      seq(1, 5)
      &rarr; Cons(1, seq(2, 5))
      &rarr; Cons(1, Cons(2, seq(3, 5)))
      &rarr; Cons(1, Cons(2, Cons(3, seq(4, 5))))
      &rarr; Cons(1, Cons(2, Cons(3, Cons(4, seq(5, 5)))))
      &rarr; Cons(1, Cons(2, Cons(3, Cons(4, Nil))))        
      </code></pre></li>
      <li>La llamada <code>seq(0, N)</code> ahora tiene coste <em class="rojo">O(N)</em>.</li>
      </ul>
    </section>
    
    <section>
      <h3>Operaciones con <code>List&lt;T&gt;</code></h3>
      <ul>
        <li>La definici칩n del tipo <code>List&lt;T&gt;</code> es recursiva:
        <pre><code class="language-kotlin" data-trim data-noescape>
          abstract class List&lt;out T&gt;
          
          object Nil : List&lt;Nothing&gt;()
          data class Cons&lt;T&gt;(val head: T, val tail: <span class="hl">List&lt;T&gt;</span>) : List&lt;T&gt;() 
        </code></pre>
        </li>
        <li>Las funciones que recorran una lista tambi칠n ser치n recursivas.</li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: m칠todo <code>length()</code></h3>
      <ul>
        <li>Definimos un m칠todo que calcule el n칰mero de elementos de la lista:</li>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.length(): Int = when (this) { <span class="arrow_box_left">Error de compilaci칩n</span>
              is Nil -> 0
              is Cons -> 1 + this.tail.length()
          }          
        </code></pre>
        <li>
        La distinci칩n de casos no es exhaustiva, y el compilador exige una rama <code>else</code>, ya que podr칤a haber m치s subclases de <code>List&lt;T&gt;</code>.
        </li>
        <li>쮺칩mo lo arreglamos? Hay dos maneras.</li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: m칠todo <code>length()</code></h3>
      <ol>
        <li>Lanzar una excepci칩n en el caso <code>else</code>:
        <pre><code class="language-kotlin" data-trim data-noescape>
fun &lt;T&gt; List&lt;T&gt;.length(): Int = when (this) {
    is Nil -> 0
    is Cons -> 1 + tail.length()
    else -> throw UnsupportedOperationException()   <span class="arrow_box_left">춰Feo!</span>
}
        </code></pre></li>
        <li>Prohibir que <code>List&lt;T&gt;</code> tenga m치s subclases, aparte de las ya definidas: <code>Nil</code> y <code>Cons</code>.
        <ul>
          <li>Es lo que haremos a continuaci칩n.</li>
        </ul></li>
      </ol>
    </section>
    
    <section>
      <h3>Definici칩n definitiva de <code>List&lt;T&gt;</code></h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
<span class="hl">sealed</span> class List&lt;out T&gt;

object Nil : List&lt;Nothing&gt;()
data class Cons&lt;T&gt;(val head: T, val tail: List&lt;T&gt;) : List&lt;T&gt;()
        
      </code></pre>
      <ul>
        <li>Mediante <code>sealed</code> indicamos que la clase <code>List&lt;T&gt;</code> es abstracta, pero se prohibe heredar de ella en cualquier otro sitio que no sea el m칩dulo en el que est치 definida.</li>
        <li>De este modo, el compilador puede saber que la clase un objeto de tipo <code>List&lt;T&gt;</code> ha de ser, o bien <code>Nil</code>, o bien una instancia de <code>Cons</code>.</li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo: m칠todo <code>length()</code></h3>
      <p>Declarando <code>List&lt;T&gt;</code> como <code>sealed</code>, la siguiente definici칩n ya se acepta por el compilador:</p>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.length(): Int = when (this) {
            is Nil -> 0
            is Cons -> 1 + this.tail.length()
        }          
      </code></pre>
      <p>Versi칩n con par치metros acumuladores y recursi칩n de cola:</p>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.length(): Int {
            tailrec fun List&lt;T&gt;.lengthRec(ac: Int): Int = when (this) {
                is Nil -> ac
                is Cons -> tail.lengthRec(ac + 1)
            }
            return this.lengthAc(0)
        }        
      </code></pre>
      <p>Coste: <em class="rojo">O(N)</em>, donde <em>N</em> es la longitud de la lista.</p>
    </section>
    
    
    <section>
      <h3>Ejemplo: m칠todo <code>length()</code></h3>
      <ul>
        <li>쮺oste <em class="rojo">O(N)</em> solo para obtener la longitud de la lista?</li>
        <li>Es posible mejorar ese coste almacenando un atributo en la clase <code>List</code> que contenga la longitud de la lista.
        <ul>
          <li><em>(Lo dejamos como ejercicio)</em></li>
        </ul></li>
        <li>Con esto podemos obtener la longitud de una lista en coste <em>O(1)</em>.
        <ul>
          <li>...a costa de guardar m치s informaci칩n en cada celda.</li>
        </ul>
        </li>
      </ul>
      
    </section>
    
    <section>
      <h3>Ejemplo: suma de los elementos de una lista</h3>
      <p>Sin recursi칩n de cola:</p>
      <pre><code class="language-kotlin" data-trim data-noescape>
      fun List&lt;Int&gt;.sum(): Int = when (this) {
          is Nil -> 0
          is Cons -> this.head + this.tail.sum()
      }        
      </code></pre>
      <p>Con recursi칩n de cola y par치metro acumulador:</p>
      <pre><code class="language-kotlin" data-trim data-noescape>
      fun List&lt;Int&gt;.sum(): Int {
          tailrec fun List&lt;Int&gt;.sumRec(ac: Int): Int = when (this) {
              is Nil -> ac
              is Cons -> tail.sumRec(ac + head)
          }
          return this.sumRec(0)
      }
      </code></pre>
      <p>Coste: <em class="rojo">O(N)</em>, donde <em>N</em> es la longitud de la lista.</p>
    </section>
    
    <section>
      <h3>Ejemplo: concatenar dos listas</h3>
      <ul>
        <li>Definimos una funci칩n <code>plus</code> que, dadas dos listas <code>xs   </code> e <code>ys</code>, devuelva el resultado de concatenar ambas:
        <pre><code class="language-kotlin" data-trim data-noescape>          
        fun &lt;T&gt; plus(xs: List&lt;T&gt;, ys: List&lt;T&gt;): List&lt;T&gt; = when (xs) {
            is Nil -> ys
            is Cons -> Cons(xs.head, plus(xs.tail, ys))
        }
        </code></pre></li>
        <li class="fragment">Ejemplo:
        <pre><code class="no-highlight" data-trim data-noescape>
          plus(<span style="background-color:#DDFFDD">Cons(1, Cons(2, Cons(3, Nil)))</span>, <span style="background-color:#FFFFDD">Cons(4, Cons(5, Nil))</span>)
          
          &rarr; Cons(1, plus(<span style="background-color:#DDFFDD">Cons(2, Cons(3, Nil))</span>, <span style="background-color:#FFFFDD">Cons(4, Cons(5, Nil))</span>))
          
          &rarr; Cons(1, Cons(2, plus(<span style="background-color:#DDFFDD">Cons(3, Nil)</span>, <span style="background-color:#FFFFDD">Cons(4, Cons(5, Nil))</span>)))
          
          &rarr; Cons(1, Cons(2, Cons(3, plus(<span style="background-color:#DDFFDD">Nil</span>, <span style="background-color:#FFFFDD">Cons(4, Cons(5, Nil))</span>))))
          
          &rarr; Cons(1, Cons(2, Cons(3, <span style="background-color:#FFFFDD">Cons(4, Cons(5, Nil))</span>)))
          
        </code></pre>
        </li>
      </ul>
      <p>
    </section>
    
    <section>
      <h3>Ejemplo: concatenar dos listas</h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
        val xs = Cons(1, Cons(2, Cons(3, Nil)))
        val ys = Cons(4, Cons(5, Nil))
        val zs = plus(xs, ys)
      </code></pre>
      <p>
      <img src="04/ConcatPersistente2.svg">
      </p>
      <p>Coste: <em class="rojo">O(N)</em>, donde <em>N</em> es la longitud de la lista pasada como primer par치metro.</p>
    </section>
    
    <section>
      <h3>Ejemplo: concatenar dos listas</h3>
      <p>Podemos hacer que <code>plus</code> sea m치s f치cil de utilizar si lo declaramos como una funci칩n de extensi칩n infija:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>          
        infix fun &lt;T&gt; List&lt;T&gt;.plus(other: List&lt;T&gt;): List&lt;T&gt; = when (this) {
            is Nil -> other
            is Cons -> Cons(this.head, this.tail plus ys)
        }
        </code></pre></li>
        <p>Ejemplo de uso:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
        val zs = xs plus ys          
        </code></pre>      
    </section>
    
    <section>
      <h3>Ejemplo: concatenar dos listas</h3>
      <p>Incluso mejor: podemos sobrecargar el operador <code>+</code> en Kotlin, declarando la funci칩n <code>plus</code> como <code>operator</code>:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>          
        <span class="hl">operator</span> fun &lt;T&gt; List&lt;T&gt;.plus(other: List&lt;T&gt;): List&lt;T&gt; = when (this) {
            is Nil -> other
            is Cons -> Cons(this.head, this.tail + ys)
        }
        </code></pre></li>
        <p>Ejemplo de uso:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
        val zs = xs + ys          
        </code></pre>
        <p>Sobrecarga de operadores en Kotlin: <a href="https://kotlinlang.org/docs/operator-overloading.html">[+]</a>
    </section>
    
    <section>
      <h3>Ejemplo: invertir una lista</h3>
      <ul>
        <li>Implementamos un m칠todo <code>reversed()</code> que invierte los elementos de la lista <code>this</code>.</li>
        <li>Por ejemplo, si <code>xs</code> denota la lista <code>[1, 2, 3]</code>, <code>xs.reversed()</code> devuelve la lista <code>[3, 2, 1]</code>.</li>
      </ul>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; = when (this) {
            is Nil -> Nil
            is Cons -> tail.reversed() + Cons(head, Nil)
        }
      </code></pre>
    </section>
    
    <section>
      <h3>Ejemplo: invertir una lista</h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; = when (this) {
            is Nil -> Nil
            is Cons -> tail.reversed() + Cons(head, Nil)
        }
      </code></pre>
      <pre><code class="no-highlight" data-trim data-noescape>
        Cons(1, Cons(2, Cons(3, Nil))).reversed()
        &rarr; Cons(2, Cons(3, Nil)).reversed() + Cons(1, Nil)
        &rarr; (Cons(3, Nil).reversed() + Cons(2, Nil)) + Cons(1, Nil)
        &rarr; ((Nil.reversed() + Cons(3, Nil)) + Cons(2, Nil)) + Cons(1, Nil)
        &rarr; (Nil + Cons(3, Nil)) + Cons(2, Nil)) + Cons(1, Nil)
        &rarr; (Cons(3, Nil) + Cons(2, Nil)) + Cons(1, Nil)
        &rarr; ...
        &rarr; Cons(3, Cons(2, Nil)) + Cons(1, Nil)
        &rarr; ...
        &rarr; Cons(3, Cons(2, Cons(1, Nil)))
      </code></pre>
    </section>
    
    <section>
      <h3>Ejemplo: invertir una lista</h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; = when (this) {
            is Nil -> Nil
            is Cons -> tail.reversed() + Cons(head, Nil)
        }
      </code></pre>
      <pre><code class="no-highlight" data-trim data-noescape>
        [1, 2, 3].reversed()
        &rarr; [2, 3].reversed() + [1]
        &rarr; ([3].reversed() + [2]) + [1]
        &rarr; (([].reversed() + [3]) + [2]) + [1]
        &rarr; (([] + [3]) + [2]) + [1]
        &rarr; ([3] + [2]) + [1]
        &rarr; ...
        &rarr; [3, 2] + [1]
        &rarr; ...
        &rarr; [3, 2, 1]
      </code></pre>
    </section>    
    
    <section>
      <h3>Ejemplo: invertir una lista</h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
        fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; = when (this) {
            is Nil -> Nil
            is Cons -> tail.reversed() + Cons(head, Nil)
        }
      </code></pre>
      <ul>
        <li>쮺u치l es el coste del algoritmo?</li>
        <li>Recordemos que la operaci칩n <code>xs + ys</code> tiene coste lineal con respecto a la longitud lista <code>xs</code>.</li>
        <li>Si <code>zs</code> es una lista de tama침o <em>N</em>, la llamada a <code>zs.reversed()</code> hace <em>N</em> llamadas al operador <code>+</code>
        <ul>
          <li>...cada una con una lista cada vez m치s grande que la anterior.</li>
        </ul>
        </li>
        <li>Por tanto, el coste es <em class="rojo">O(N<sup>2</sup>)</em>.</li>
      </ul>
    </section>
    
    <section>
      <h3>Mejorando la eficiencia de <code>reversed()</code></h3>
      <ul>
        <li>Es posible mejorar el coste mediante un par치metro acumulador:
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; {          
              tailrec fun List&lt;T&gt;.reversedRec(ac: List&lt;T&gt;): List&lt;T&gt; = when(this) {
                  is Nil -> ac
                  is Cons -> tail.reversedRec(Cons(head, ac))
              }
              
              // Llamada inicial:
              return reversedRec(Nil)
          }          
        </code></pre>
        </li>
        <li>El par치metro <code>ac</code> acumula la lista invertida.</li>
      </ul>
    </section>
    
    <section>
      <h3>Mejorando la eficiencia de <code>reversed()</code></h3>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; {          
              tailrec fun List&lt;T&gt;.reversedRec(ac: List&lt;T&gt;): List&lt;T&gt; = when(this) {
                  is Nil -> ac
                  is Cons -> tail.reversedRec(Cons(head, ac))
              }
              
              // Llamada inicial:
              return reversedRec(Nil)
          }          
        </code></pre>
        <pre><code class="no-highlight" data-trim data-noescape>
          Cons(1, Cons(2, Cons(3, Nil))).reversed()
          &rarr; Cons(1, Cons(2, Cons(3, Nil))).reversedRec(Nil)
          &rarr; Cons(2, Cons(3, Nil)).reversedRec(Cons(1, Nil))
          &rarr; Cons(3, Nil).reversedRec(Cons(2, Cons(1, Nil)))
          &rarr; Nil.reversedRec(Cons(3, Cons(2, Cons(1, Nil))))
          &rarr; Cons(3, Cons(2, Cons(1, Nil)))
        </code></pre>
    </section>

    <section>
      <h3>Mejorando la eficiencia de <code>reversed()</code></h3>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.reversed(): List&lt;T&gt; {          
              tailrec fun List&lt;T&gt;.reversedRec(ac: List&lt;T&gt;): List&lt;T&gt; = when(this) {
                  is Nil -> ac
                  is Cons -> tail.reversedRec(Cons(head, ac))
              }
              
              // Llamada inicial:
              return reversedRec(Nil)
          }          
        </code></pre>
        <pre><code class="no-highlight" data-trim data-noescape>
          [1, 2, 3].reversed()
          &rarr; [1, 2, 3].reversedRec([])
          &rarr; [2, 3].reversedRec([1])
          &rarr; [3].reversedRec([2, 1])
          &rarr; [].reversedRec([3, 2, 1])
          &rarr; [3, 2, 1]
        </code></pre>
        <p>Coste: <em class="rojo">O(N)</em>, donde <em>N</em> es la longitud de la lista.</p>
    </section>
    
    <section>
      <h3>Ejemplo: <code>last()</code></h3>
      <ul>
        <li>Implementamos una funci칩n que devuelva el 칰ltimo elemento de una lista:
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; List&lt;T&gt;.last(): T = when(this) {
            is Nil -> ???                 <span class="arrow_box_left">쯈u칠 devolvemos si la lista es vac칤a?</span>
            is Cons -> when (tail) {
              is Nil -> head
              is Cons -> tail.last()
            }
          }
        </code></pre>
        </li>
        <li>La funci칩n es parcial: solo puede aplicarse a listas no vac칤as.</li>
        <li>쯈u칠 hacemos si llamamos a <code>last()</code> sobre una lista vac칤a.</li>
        
      </ul>
    </section>
    
    <section>
      <h3>쮺칩mo tratar las funciones parciales?</h3>
      <p>Hay varias posibilidades:</p>
      <ol>
        <li>Lanzar una excepci칩n en el caso en el que <code>this</code> es la lista vac칤a.
        <ul>
          <li>Evitaremos las excepciones en esta asignatura.</li>
        </ul>
        </li>
        <li>Devolver un tipo <code>Option&lt;T&gt;</code>, o devolver <code>null</code>.
        <ul>
          <li>Veremos ambas alternativas m치s adelante (pero no ahora).</li>
        </ul></li>
        <li>Prohibir las llamadas con listas no vac칤as.
        <ul>
          <li>Es lo que haremos a continuaci칩n.</li>
        </ul>
        </li>
      </ol>
    </section>
    
    <section>
      <h3>쮺칩mo tratar las funciones parciales?</h3>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; <span class="hl">Cons&lt;T&gt;</span>.last(): T = when(this.tail) {
              is Nil -> head
              is Cons -> this.tail.last()
          }
        </code></pre>
        <ul>
          <li>Ya no se permite llamar a <code>last()</code> sobre la lista <code>Nil</code>.</li>          
        </ul>
    </section>
    
    <section>
      <h3>쮺칩mo tratar las funciones parciales?</h3>
      <ul>
        <li>Si queremos que una funci칩n solamente sea aplicable a una lista no vac칤a, basta declarar el tipo del par치metro (o receptor) como <code>Cons&lt;T&gt;</code>, en lugar de <code>List&lt;T&gt;</code>.</li>
        <li>Como el nombre <code>Cons&lt;T&gt;</code> no es demasiado ilustrativo, Kotlin nos permite declarar tipos nuevos como sin칩nimos de otros:
        <pre><code class="language-kotlin" data-trim data-noescape>
          typealias NonEmptyList&lt;T&gt; = Cons&lt;T&gt;
        </code></pre>
        </li>
      </ul>
    </section>
    

    <section>
      <h3>쮺칩mo tratar las funciones parciales?</h3>
        <p>Resultado:</p>
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; <span class="hl">NonEmptyList&lt;T&gt;</span>.last(): T = when(this.tail) {
              is Nil -> head
              is Cons -> this.tail.last()
          }
        </code></pre>
    </section>
    
    
    <section>
      <h3>Librer칤a <code>collections.immutable</code></h3>
      <ul>
        <li>La biblioteca est치ndar de Kotlin no proporciona soporte para EDs persistentes.
        <ul>
          <li>Las colecciones inmutables est치n basadas en clases ya existentes de Java.</li>
          <li>Por ejemplo, <code>listOf(...)</code> devuelve un <code>ArrayList</code>.</li>
        </ul>
        </li>
        <li>Sin embargo, existe una biblioteca separada para EDs persistentes:
        <a href="https://github.com/Kotlin/kotlinx.collections.immutable">kotlinx.collections.immutable</a>
        </li>
      </ul>
    </section>
    
    <section>
      <h3>Uso de la biblioteca con proyectos <em>Gradle</em></h3>
      <ul>
        <li>Basta con a침adir la siguiente l칤nea en la secci칩n <code>dependencies</code> del fichero <code>build.gradle.kts</code> con la configuraci칩n del proyecto:
        <pre style="font-size:40%"><code class="language-kotlin" data-trim data-noescape>
          dependencies {
              ...
              <span class="hl">implementation("org.jetbrains.kotlinx:kotlinx-collections-immutable:0.3.5")</span>
          }          
        </code></pre>
        </li>
        <li>Al compilar el proyecto, Gradle descarga e incorpora las clases de la biblioteca en el <em>class path</em>.</li>
      </ul>
    </section>
    
    <section>
      <h3>Ejemplo de uso</h3>
      <pre><code class="language-kotlin" data-trim data-noescape>
        val l1 = persistentListOf(1, 2, 3)
        val l2 = persistentListOf(4, 5)
        val l3 = println(l1 + l2)
        
        println(l1)   // &rarr; [1, 2, 3]
        println(l2)   // &rarr; [4, 5]
        println(l3)   // &rarr; [1, 2, 3, 4, 5]        
      </code></pre>
    </section>
    
    <section>
      <h3>Ejemplo de uso</h3>
      <ul>
        <li>El objeto devuelto por <code>persistentListOf()</code> implementa la interfaz <code>List&lt;T&gt;</code>, por lo que es posible utilizar cualquier funci칩n de la biblioteca de Kotlin <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">[+]</a>.
        <pre><code class="language-kotlin" data-trim data-noescape>
          val l1 = persistentListOf(1, 2, 3)
          val l2 = persistentListOf(4, 5)
          val l3 = l1 + l2
          
          println(l3.reversed())    // &rarr; [5, 4, 3, 2, 1]
          println(l3.sum())         // &rarr; 9
        </code></pre>
        </li>
      </ul>
    </section>
    
    
    
    
    
    
    <!--
    <section>
      <h3>Costes de acceso a una lista</h3>
      <ul>
        <li>쯈u칠 coste tiene acceder al primer elemento de una lista?
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; NonEmptyList&lt;T&gt;.first(): T = <span class="fragment">head</span>
        </code></pre>
        <p class="fragment">Coste: <em class="rojo">O(1)</em></p>
        </li>
        <li>쯈u칠 coste tiene acceder al 칰ltimo elemento de una lista?
        <pre><code class="language-kotlin" data-trim data-noescape>
          fun &lt;T&gt; NonEmptyList&lt;T&gt;.last(): T = <span class="fragment">when (tail) {
              is Nil -> head
              is Cons -> tail.last()
          }</span>
        </code></pre>
        <p class="fragment">Coste: <em class="rojo">O(N)</em>, donde <em>N</em> es la longitud de la lista.</p>
        </li>        
        
      </ul>
    </section>
    
    <section>
      <h3>Costes de acceso a una lista</h3>
      
    </section>
    -->
    
    
        <section>
            <h2>Bibliograf칤a</h2>
            <div style="float:left; width:70%; font-size: 95%">
                <ul>
                    <li>M. Vermeulen, R. Bjarnason, P. Chiusano
                        <br>
                        <em>Functional Programming in Kotlin</em>
                        <br> Manning Publications (2021)
                        <br> Cap칤tulo 3
                    </li>
                    <li style="margin-top:3em">
                        <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">Kotlin Standard Library: interfaz List&lt;T&gt;</a>
                        <br> https://kotlinlang.org/api/latest/jvm/stdlib/
                    </li>
                </ul>
            </div>
            <div style="float:right; width: 30%">
                <img src="https://images.manning.com/book/f/ac70811-658d-439c-8c07-605e7a8a2e19/Vermeulen-HI.png" style="width:50%; border:none"><br/>
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/06/Kotlin_Icon.svg/512px-Kotlin_Icon.svg.png?20171012085709" style="width:30%; border:none">
                
            </div>            
        </section>
    
    
    
    
    </div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
      Reveal.configure({ pdfSeparateFragments: false });
		</script>
	</body>
</html>
